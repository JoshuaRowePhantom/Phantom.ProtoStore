syntax = "proto3";

import "google/protobuf/descriptor.proto";
import "google/protobuf/any.proto";
import "Phantom.ProtoStore/ProtoStore.proto";

package Phantom.ProtoStore;

message Header {
	uint32 Version = 1;
	uint32 LogAlignment = 2;
	repeated uint64 LogReplayExtentNumbers = 3;
	uint64 Epoch = 5;
	uint64 NextIndexNumber = 6;
	uint64 NextDataExtentNumber = 7;
}

message LoggedRowWrite {
	uint64 IndexNumber = 1;
	bytes Key = 2;
	bytes Value = 3;
	uint64 SequenceNumber = 4;
	uint64 CheckpointNumber = 5;
}

message LoggedAction {
	oneof LoggedActionType {
		google.protobuf.Any ArbitraryAction = 1;
		LoggedCheckpoint LoggedCheckpoints = 2;
		LoggedCreateDataExtent LoggedCreateDataExtents = 3;
		LoggedDeleteDataExtent LoggedDeleteDataExtents = 4;
		LoggedCommitDataExtent LoggedCommitDataExtents = 5;
		LoggedCreateIndex LoggedCreateIndex = 6;
    }
}

message LoggedCreateIndex {
	uint64 IndexNumber = 1;
}

message LoggedCreateDataExtent {
	uint64 ExtentNumber = 1;
}

message LoggedDeleteDataExtent {
	uint64 ExtentNumber = 1;
}

message LoggedCommitDataExtent {
	uint64 ExtentNumber = 1;
}

message LoggedCheckpoint {
	uint64 IndexNumber = 1;
	repeated uint64 CheckpointNumber = 2;
	repeated uint64 PartitionsDataExtentNumbers = 3;
}

message LogRecordExtras {
	repeated LoggedAction LoggedActions = 1;
}

message LogRecord {
	uint32 Alignment = 1;
	// Most log records are for rows, so put them right in the message.
	repeated LoggedRowWrite Rows = 2;
	// Most log records don't have extras, so put them in another message.
	LogRecordExtras Extras = 3;
}

message InternalKeyPrefixMetadata {
}

message InternalKeySuffixMetadata {
	uint64 SequenceNumber = 1 [(FieldOptions) = {
		SortOrder: Descending;
	}];
}

message InternalKey {
	bytes KeyMessage = 20;

	uint64 SequenceNumber = 30 [(FieldOptions) = {
		SortOrder: Descending;
	}];
}

message InternalValue {
	oneof Value {
		bytes ValueMessage = 20;
    }
}

message IndexesByNameKey {
	string IndexName = 1;
}

message IndexesByNameValue {
	uint64 IndexNumber = 1;
}

message IndexesByNumberKey {
	uint64 IndexNumber = 1;
}

message IndexesByNumberValue {
	IndexSchemaDescription Schema = 1;
	string IndexName = 2;
	uint64 CreateSequenceNumber = 3;
}

message PartitionsKey {
	uint64 IndexNumber = 1;
	uint64 DataExtentNumber = 2;
}

message PartitionsValue {
	uint64 HeaderExtentNumber = 1;
	uint64 Level = 2;
	uint64 Size = 3;
}

message MergesKey {
	uint64 IndexNumber = 1;
	string MergesUniqueId = 2;
}

message MergesValue {
	repeated uint64 SourceDataExtentNumbers = 1;
}

message MergeChunksKey {
	string MergesUniqueId = 1;
	uint64 MergeChunkNumber = 2;
}

enum MergeChunkStatus {
	NotStarted = 0;
	Incomplete = 1;
	Complete = 2;
}

message MergeChunksValue {
	MergeChunkStatus MergeChunkStatus = 1;
	uint64 DestinationDataExtentNumber = 2;
	uint64 StartRowIndex = 3;
	uint64 EndRowIndex = 4;
}

message PartitionTreeEntryValue {
	oneof PartitionTreeEntryValue {
		// Set if this entry is an inline small value.
		bytes Value = 1;
		// Set if this entry is an offset into the file.
		uint64 ValueOffset = 2;
		bool Deleted = 3;
    }
	uint64 WriteSequenceNumber = 4;
}

message PartitionTreeEntryValueSet {
	// A set of values sorted by decreasing sequence number.
	repeated PartitionTreeEntryValue Values = 1;
}

message PartitionTreeEntry {
	// The key for this tree entry,
	// or the highest key in the subtree owned by this tree entry.
	bytes Key = 1;
	uint64 LowestWriteSequenceNumber = 2;
	uint64 HighestWriteSequenceNumber = 3;
	oneof PartitionTreeEntryType {
		// Set if the tree points to a subtree.
		uint64 TreeNodeOffset = 4;
		// Set if the tree points to a single value
		PartitionTreeEntryValue Value = 5;
		// Set if the tree points to multiple values for the
		// same key but different sequence numbers.
		PartitionTreeEntryValueSet ValueSet = 6;
    }
}

message PartitionTreeNode {
	repeated PartitionTreeEntry TreeEntries = 1;
	uint64 Level = 2;
	uint64 Size = 3;
	uint64 SizeRunningTotal = 4;
	uint64 ApproximateKeyCount = 5;
	uint64 ApproximateKeyCountRunningTotal = 6;
}

enum PartitionBloomFilterHashAlgorithm {
	Version1 = 0;
}

message PartitionBloomFilter {
	PartitionBloomFilterHashAlgorithm Algorithm = 1;
	uint32 HashFunctionCount = 2;
	bytes Filter = 3;
}

message PartitionRoot {
	uint64 RootTreeNodeOffset = 1;
	uint64 RowCount = 2;
	uint64 BloomFilterOffset = 3;
}

message PartitionHeader {
	fixed64 PartitionRootOffset = 1;
}

message PartitionMessage {
	oneof PartitionMessageType {
		PartitionHeader PartitionHeader = 1;
		PartitionRoot PartitionRoot = 2;
		PartitionTreeNode PartitionTreeNode = 3;
		PartitionBloomFilter PartitionBloomFilter = 4;
		bytes Value = 5;
	}
}
