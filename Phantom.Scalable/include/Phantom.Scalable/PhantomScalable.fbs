namespace Phantom.Scalable.FlatBuffers;

table AlignedValue
{
    value: [byte];
    alignment: ubyte = 4;
}

table Any
{
    type: string;
    value : AlignedValue;
}

table Fault
{
    payload : Any;
}

table RequestId
{
    value : [byte];
}

table TransactionId
{
    value : [byte];
}

table PerformRequest
{
}

table TransactionRequest
{
}

table PutServiceRequest
{
}

table GetServiceRequest
{
}

table KeyValueStoreRequest
{}

union ServiceRequestUnion
{
    put : PutServiceRequest,
    get : GetServiceRequest,
}

table ServiceRequest
{
    union : ServiceRequestUnion;
}

table CacheRequest
{
}

union RequestUnion
{
    service_request : ServiceRequest,
    key_value_store_request : KeyValueStoreRequest,
    cache_request : CacheRequest,
    perform_request : PerformRequest,
    transaction_request : TransactionRequest,
}

table Request
{
    request_id : RequestId;
    transaction_id : TransactionId;
    request : RequestUnion;
}

table ClientToServerMessage
{
    requests : [Request];
}

table ServiceResponse
{
}

table PerformResponse
{
}

table TransactionResponse
{
}

table KeyValueStoreResponse
{
}

table CacheResponse
{
}

union ResponseUnion
{
    service_response : ServiceResponse,
    key_value_store_response : KeyValueStoreResponse,
    cache_response : CacheResponse,
    perform_response : PerformResponse,
    transaction_response : TransactionResponse,
    fault : Fault,
}

table Response
{
    request_id : RequestId;
    response : ResponseUnion;
}

table ServerToClientMessage
{
    responses : [Response];
}

table KeyValuePair
{
    key : string;
    value : string;
}

table Tags
{
    tags : [KeyValuePair];
}

struct BinaryId
{
    value : [byte:16];
}

table Id
{
    values : [string];
    binary_id : BinaryId;
}

table Tag
{
    id : Id;
    tags : Tags;
}

table Address
{
    tag : Tag;
    address : [string];
}

table AddressSelector
{
    tag : Tag;
}

table Node
{
    tag : Tag;
    node_addresses : [Address];
}

table TagMatchRule
{
    tag : Tag;

    // The set of tags that must match.
    // For each distinct key, the item is matched if any of the include_tags' values match.
    // For any key in include_tags with an empty value, any value for that key will be considered a match.
    include_tags : Tags;

    // The set of tags that must NOT match.
    // Any match of any of the exclude_tags will cause the item to not match.
    // For any key in exclude_tags with an empty value, any value for that key will cause the item to not match.
    exclude_tags : Tags;
}

table TagMatch
{
    tag : Tag;

    rules : [TagMatchRule];
}

// Groups nodes into collections for redundancy calculations.
// A NodeGrouping is a set of rules that define how nodes are grouped.
// A NodeGrouping is NOT a set of nodes, but represents a SET of SETs of nodes
// based on a set of tags applied to nodes.
table NodeGrouping
{
    tag : Tag;

    // The tags that nodes must match to be in the grouping.
    node_tag_match : TagMatch;

    // The set of tag names to use to generate groups.
    node_tag_grouping : [string];
}

table DataDistribution
{
    // The set of tag matches that define the groups.
    grouping : [TagMatch];

    // The set of group names to use to compute redundancy of data.
    // Two nodes are allowed to have copies of the same data item if
    // all of their redundancy groups are disjoint.
    redundancy_grouping_names : [Id];
}

table ResourceTag
{
    tag : Tag;
    resource_group : Id;
}

table ResourceGroup
{
    tag : ResourceTag;
}

// This service is used internally to store key-value pairs
// backing other service types.
table KeyValueStoreService
{
    resource_group : Id;
    data_distribution : DataDistribution;
}

table CertificateId
{
    thumbprint : [byte];
}

// This service defines the global parameters for a Phantom.Scalable cluster.
table ScalableService
{
    node_signing_authorities : [CertificateId];
}

// This service is used internally to cache ephemeral data
table CacheService
{
}

union ProvidedServiceUnion
{
    scalable_service : ScalableService,
    key_value_store : KeyValueStoreService,
    cache_service : CacheService,
}

table ProvidedService
{
    resource_tag : ResourceTag;
    provided_service : ProvidedServiceUnion;
}
